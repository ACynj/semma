# 有效参考和噪音的量化判断方法（改进版）

## 概述

改进后的量化方法使用**有效性分数（0-1）**来评估每个相似关系的有效性，而不是简单的二元判断。这样可以更准确地量化参考的质量。

## 量化公式

### 1. 有效性分数计算

对于测试样本 `(test_h, test_r, test_t)` 和相似关系 `similar_rel`（相似度为 `similarity`）：

#### Tail预测有效性评分

**情况1：直接匹配（最高分）**
```
如果 test_t ∈ train_tail_contexts[(test_h, similar_rel)]:
    候选集合大小 = |train_tail_contexts[(test_h, similar_rel)]|
    大小因子 = 1.0 / (1.0 + log10(候选集合大小))
    分数 = 1.0 × similarity × 大小因子
```

**情况2：仅提供上下文（中等分）**
```
如果 (test_h, similar_rel) 在训练数据中，但 test_t 不在候选集合中:
    候选集合大小 = |train_tail_contexts[(test_h, similar_rel)]|
    大小因子 = 1.0 / (1.0 + log10(候选集合大小))
    基础分 = 0.4
    分数 = 0.4 × similarity × 大小因子
```

#### Head预测有效性评分

与Tail预测类似，使用 `train_head_contexts[(similar_rel, test_t)]`。

#### 最终分数

```
最终分数 = max(tail_score, head_score)
```

### 2. 有效性阈值

- **有效性阈值 = 0.3**
- 只有 `最终分数 >= 0.3` 的相似关系才被判定为**有效参考**
- 否则被判定为**噪音**

## 量化指标说明

### 核心指标

1. **平均有效性分数（所有参考）**
   - 所有相似关系的平均有效性分数
   - 范围：0-1
   - 越高说明参考质量越好

2. **有效参考平均分数（仅有效参考）**
   - 只计算被判定为有效的参考的平均分数
   - 范围：0.3-1（因为阈值是0.3）
   - 越高说明有效参考的质量越好

3. **直接匹配数/比例**
   - 直接匹配：`test_t` 或 `test_h` 在候选集合中
   - 这是最有效的参考类型

4. **仅上下文数/比例**
   - 仅提供上下文：相似关系在训练数据中出现，但未直接匹配
   - 提供约束信息，但有效性较低

### 统计指标

- **总参考数**：所有相似关系的总数
- **有效参考数**：分数 >= 0.3 的参考数
- **噪音参考数**：分数 < 0.3 的参考数
- **有效性率** = 有效参考数 / 总参考数
- **噪音率** = 噪音参考数 / 总参考数

## 改进点

### 1. 引入分数机制
- **之前**：二元判断（有效/无效）
- **现在**：0-1分数，更细粒度

### 2. 考虑相似度权重
- 相似度越高，分数越高
- 公式：`分数 = 基础分 × similarity × 大小因子`

### 3. 考虑候选集合大小
- 候选集合越小，匹配价值越高（信息更精确）
- 使用对数缩放：`大小因子 = 1.0 / (1.0 + log10(候选集合大小))`

### 4. 区分直接匹配和上下文
- **直接匹配**：最高分（1.0 × similarity × 大小因子）
- **仅上下文**：中等分（0.4 × similarity × 大小因子）

### 5. 设置有效性阈值
- 只有分数 >= 0.3 才算有效
- 避免将低质量参考误判为有效

## 示例

### 示例1：直接匹配（高分）

```
测试样本: (entity_A, relation_X, entity_B)
相似关系: relation_Y (相似度=0.9)

训练数据中存在: (entity_A, relation_Y, entity_B)
候选集合大小: 5

计算:
  大小因子 = 1.0 / (1.0 + log10(5)) ≈ 0.699
  分数 = 1.0 × 0.9 × 0.699 ≈ 0.629

结果: 有效参考（分数 >= 0.3），类型：直接匹配
```

### 示例2：仅提供上下文（中等分）

```
测试样本: (entity_A, relation_X, entity_B)
相似关系: relation_Y (相似度=0.85)

训练数据中存在: (entity_A, relation_Y, entity_C)  # entity_C ≠ entity_B
候选集合大小: 10

计算:
  大小因子 = 1.0 / (1.0 + log10(10)) ≈ 0.5
  分数 = 0.4 × 0.85 × 0.5 = 0.17

结果: 噪音（分数 < 0.3）
```

### 示例3：完全无关（低分）

```
测试样本: (entity_A, relation_X, entity_B)
相似关系: relation_Y (相似度=0.8)

训练数据中不存在: (entity_A, relation_Y, ...)

计算:
  分数 = 0.0

结果: 噪音（分数 < 0.3）
```

## 输出格式

### 控制台输出

```
📈 统计结果:
  总样本数: 500
  有参考的样本数: 500 (100.00%)
  总参考数: 47833
  有效参考数: 280 (0.59%)
  噪音参考数: 47553 (99.41%)
  有有效参考的样本数: 132 (26.40%)
  只有噪音的样本数: 368 (73.60%)

📊 有效性量化指标:
  平均有效性分数: 0.1234 (所有参考)
  有效参考平均分数: 0.5678 (仅有效参考)
  直接匹配数: 150 (53.57% of effective)
  仅上下文数: 130 (46.43% of effective)
```

### CSV输出

新增列：
- `avg_effectiveness_score`: 平均有效性分数（所有参考）
- `avg_effective_score`: 有效参考平均分数
- `direct_match_count`: 直接匹配数
- `direct_match_ratio`: 直接匹配比例
- `context_only_count`: 仅上下文数
- `context_only_ratio`: 仅上下文比例

## 优势

1. **更准确的量化**：使用分数而不是二元判断
2. **考虑相似度**：高相似度的关系权重更高
3. **考虑精确度**：候选集合越小，匹配价值越高
4. **区分质量**：区分直接匹配和仅提供上下文
5. **可调阈值**：可以根据需要调整有效性阈值（当前为0.3）

## 参数调整

如果需要调整量化方法，可以修改以下参数：

1. **有效性阈值** (`effectiveness_threshold`): 默认0.3
2. **直接匹配基础分**: 当前为1.0
3. **仅上下文基础分**: 当前为0.4
4. **大小因子公式**: 当前使用对数缩放

这些参数在 `check_reference_effectiveness` 函数中可以调整。

