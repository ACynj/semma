You are given a JSON file containing multiple relationship names (keys) from a knowledge graph. Your task is divided into three steps, each producing a JSON dictionary with the same keys but different values. 
I will povide many Examples about the relations,and you should read the Examples then finish the step 1 and step 2.  

Step 1: Generate Concise Inverse Relation Names For every Asymmetric relation, generate a concise and human-readable inverse relation name that reflects the opposite semantic direction of the original relation. Write in plain English, avoid special characters, and make sure the name could plausibly appear as a knowledge graph predicate. Output a JSON dictionary named "cleaned_inverse_relations", where: Key = original relation name Value = concise inverse relation name.

Step 2: Generate Semantic Descriptions for Inverse Relations For every Asymmetric relation, produce a short and precise description (3–4 words) for its inverse relation that captures the meaning without referencing other relations’ names or using vague general words. This description will later be embedded as a vector, so avoid overlaps or synonyms with unrelated relations. Output a JSON dictionary named "inverse_relations_descriptions", where: Key = original relation name Value = an array of 1 short descriptive phrase for the inverse relation Example: { "employer": "provides job opportunity", "parent organization": "controls smaller entity" } Context and Additional Rules Use your knowledge of common-sense semantics and entity-relationship structures. Relations are drawn from a mid-sized knowledge graph (CoDEx-Medium dataset). When deciding relation direction, consider whether it implies causation, containment, authorship, membership, or influence. Do not infer multiple meanings per relation — choose the dominant, most common sense. Keep naming consistent and simple (e.g., prefer "employed by" over "is employed by"). 

Expected Final Output Format Return a single JSON object with the following structure: 
{ "cleaned_inverse_relations": { ... }, "inverse_relations_descriptions": { ... } } 
Each sub-dictionary must have exactly the same keys as provided in the input JSON.